
--100번사원의 모든 부하직원을 계층형(조직도)구조로 조회한다.
 SELECT LEVEL 
      , EMPLOYEE_ID
 	  , FIRST_NAME || ' ' || LAST_NAME AS NAME --한줄로 연결
 	  , MANAGER_ID
   FROM EMPLOYEES
  START WITH EMPLOYEE_ID = 100 --100번사원의 MANAGER_ID가 0이므로 Root Node로 지정
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID --연결 조건 지정
;										  --사원번호 100번은 누군가의 상사사원번호다
-- 100번부터 시작해서 모든 부하직원들을 계층구조로 조회된다.

-- 108번사원의 모든 부하직원들을 계층형(조직도) 구조로 조회한다
-- ROOT NODE ==> 108
 SELECT LEVEL 
      , EMPLOYEE_ID
      , FIRST_NAME || ' ' || LAST_NAME AS NAME
      , MANAGER_ID
   FROM EMPLOYEES
  START WITH EMPLOYEE_ID = 108 --113
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID 
; -- ROOT NODE를 108로 지정했기때문에, 108번의 LEVEL이 1로 변경됨


--113번의 모든상사를 계층형(조직도) 구조로 조회한다
 SELECT LEVEL 
      , EMPLOYEE_ID
      , FIRST_NAME || ' ' || LAST_NAME AS NAME
      , MANAGER_ID
   FROM EMPLOYEES
  START WITH EMPLOYEE_ID = 113
CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID --113의 상사번호는 누군가의 사원번호
  ORDER BY LEVEL DESC
;


-- MANAGER_ID가 NULL 인 사원의 모든 부하직원을 조회한다
SELECT EMPLOYEE_ID
 	  , FIRST_NAME || ' ' || LAST_NAME AS NAME
      --, MANAGER_ID
   FROM EMPLOYEES
  START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID 
;

-- 113번 사원의 모든 부하직원을 조회한다
 SELECT EMPLOYEE_ID
 	  , FIRST_NAME || ' ' || LAST_NAME AS NAME
      , MANAGER_ID
   FROM EMPLOYEES
  START WITH EMPLOYEE_ID = 113
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID 
;

-- 60번 부서 부서장의 모든 부하직원을 조회한다
  
-- 60번부서 구하기
-- 60번 부서의 부서장 구하기
-- 60번부서의 부서장의 부하직원 구하기
  SELECT EMPLOYEE_ID
 	   , FIRST_NAME || ' ' || LAST_NAME AS NAME
       , EMP_MANAGER_ID
    FROM (SELECT D.DEPARTMENT_ID
    		   , D.MANAGER_ID AS DEPT_MANAGER_ID
    		   , E.EMPLOYEE_ID
    		   , E.FIRST_NAME
    		   , E.LAST_NAME
    		   , E.MANAGER_ID AS EMP_MANAGER_ID
			FROM DEPARTMENTS D
			JOIN EMPLOYEES E
			  ON D.DEPARTMENT_ID  = E.DEPARTMENT_ID 
			  -- ON D.MANAGER_ID = E.EMPLOYEE_ID
		   WHERE D.DEPARTMENT_ID = 60) STH
   START WITH STH.DEPARTMENT_ID = 60
 CONNECT BY PRIOR EMPLOYEE_ID = STH.EMP_MANAGER_ID
;



-- 젤쉬운 풀이 : 서브쿼리 이용 -- 60번부서의 부서장의 부하직원 구하기
 SELECT EMPLOYEE_ID 
      , FIRST_NAME || ' ' || LAST_NAME AS NAME
      , MANAGER_ID
   FROM EMPLOYEES 
  START WITH EMPLOYEE_ID = (SELECT MANAGER_ID
						  FROM DEPARTMENTS 
						  WHERE DEPARTMENT_ID = 60)
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;


-- 역방향 문제 
-- 1. 60번 부서장의 상사를 역순으로 조회한다
 SELECT LEVEL 
 , EMPLOYEE_ID
      , FIRST_NAME || ' ' || LAST_NAME AS NAME
      , MANAGER_ID
   FROM EMPLOYEES 
  START WITH EMPLOYEE_ID = (SELECT MANAGER_ID
						  FROM DEPARTMENTS 
						  WHERE DEPARTMENT_ID = 60)
CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID
  ORDER BY LEVEL DESC
;

-- 문제2.  부하직원이 없는 사원을 모두 조회한다 (START WITH CONNECT BY PRIOR 사용하지 X, 같은테이블을 두번 조인) 89개
SELECT *
  FROM EMPLOYEES E
  JOIN DEPARTMENTS D
    ON D.MANAGER_ID = E.EMPLOYEE_ID 
  WHERE E.EMPLOYEE_ID NOT IN D.MANAGER_ID 
  
--풀이 1) 서브쿼리 - 내사원번호가 누군가의 매니저아이디로 없다
SELECT *
  FROM EMPLOYEES 
  WHERE EMPLOYEE_ID NOT IN (SELECT MANAGER_ID
  							  FROM EMPLOYEES 
  							 WHERE MANAGER_ID IS NOT NULL) --NOT IN 은 반드시 NULL CHECK 해주기(NULL값 있으면 값이 안나옴)
;
-- 풀이 2) LEFT OUTER JOIN으로 풀기
SELECT MAN.*
  FROM EMPLOYEES MAN
  LEFT JOIN EMPLOYEES EMP
    ON MAN.EMPLOYEE_ID = EMP.MANAGER_ID 
 WHERE EMP.EMPLOYEE_ID IS NULL 
 ORDER BY MAN.EMPLOYEE_ID
 ;


--문제 3. 부하직원이 없는 사원의 상사를 모두 조회한다. --내사원번호가 누군가의 매니저아이디로 없다
-- 풀이1
 SELECT LEVEL 
      , EMPLOYEE_ID
      , FIRST_NAME || ' ' || LAST_NAME AS NAME
      , MANAGER_ID
   FROM EMPLOYEES 
  START WITH EMPLOYEE_ID NOT IN (SELECT MANAGER_ID
  							       FROM EMPLOYEES 
  							      WHERE MANAGER_ID IS NOT NULL)
CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID

-- 풀이2
  SELECT LEVEL 
       , EMPLOYEE_ID
       , FIRST_NAME || ' ' || LAST_NAME AS NAME
       , MANAGER_ID
    FROM EMPLOYEES 
   START WITH EMPLOYEE_ID IN (SELECT MAN.*
   							    FROM EMPLOYEES MAN
    							LEFT JOIN EMPLOYEES EMP
    							  ON MAN.EMPLOYEE_ID = EMP.MANAGER_ID 
 							   WHERE EMP.EMPLOYEE_ID IS NULL )	--여기서 역순조회하면 레벨이 깨짐
 CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID
